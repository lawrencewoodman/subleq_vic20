;========================================================
; SUBLEQ Emulator
; Author  Lawrence woodman <lwoodman@vlifesystems.com>
; Date    31st March 2020
;--------------------------------------------------------
; Include as needed
;--------------------------------------------------------
; TODO check if A, B, and C are in range?
; TODO Add support for input via A == -1
;========================================================

; TODO prefix these with SL_
; TODO Check and document locations and probs
A           = $A7               ; A Operand
B           = $A9               ; B Operand
C           = $AB               ; C Operand
PC          = $BE               ; TODO Find better location
HPTR        = $92               ; TODO Find better location
NPTR        = $94               ; TODO Find better location
SL_MEM      = $1500             ; TODO Find better location



;-------------------------------------------------
; Load a program into memory
;-------------------------------------------------
; Args:
;   SL_prog    Location of program to load. First
;              byte/word is the length of the program
;              in bytes.  Uses 16-bit words.
;   SL_MEM     Location of SUBLEQ memory
;-------------------------------------------------
; TODO Correct prog comment byte/word
; TODO put this into another program
; TODO Make possible to load > 128 16-bit word programs
;-------------------------------------------------
SL_loadProg  .(
            ; Get Program size and double it because
            ; program stored as 16-bit words
            clc
            lda SL_prog
            adc SL_prog

            ; Load program into SL_MEM
            tay
            ldx #$00
loop        lda SL_prog+1, x
            sta SL_MEM, x
            inx
            dey
            bne loop
            rts
.)


;-------------------------------------------------
; Run program
;-------------------------------------------------
; Args:
;   SL_MEM     Location of SUBLEQ memory
;-------------------------------------------------
SL_run      .(
CCHROUT     = $FFD2
            ; Zero PC
            lda #00
            sta PC
            sta PC+1

fetch       ; Check if PC valid (PC >= 0)
            lda PC+1
            and #128                 ; Most significant bit (sign bit)
            beq fetch1
            jmp halt

            ;--------------------
            ; Fetch operands A,B,C
            ;--------------------

fetch1      ; Calc native pointer for PC
            lda PC
            sta HPTR
            lda PC+1
            sta HPTR+1
            jsr SL_CalcNPTR

            ; Get A,B,C
            ldy #05
floop       lda (NPTR),y
            sta A,y
            dey
            bpl floop

            ; Move PC to start of next operands
            clc
            lda PC
            adc #03
            sta PC
            bcc fetchEnd
            inc PC+1
fetchEnd

            ;------------------------------------------------------------
            ; Output mem[A] to display if B -1 and move to next operands
            ;------------------------------------------------------------

            ; Check if B == -1 indicating that mem[A] should be output
            lda B
            cmp #<(-1)
            bne sub
            lda B+1
            cmp #>(-1)
            bne sub

            ; Calc native pointer for A
            lda A
            sta HPTR
            lda A+1
            sta HPTR+1
            jsr SL_CalcNPTR

            ; Output LSB of mem[A] to display
            ldx #00
            lda (NPTR, x)
            jsr CCHROUT
            jmp fetch

            ;-----------------------------------
            ; Perform subtraction
            ; mem[B] = mem[B] - mem[A]
            ; TODO create routine to repoint A and B and use before SL_Output
            ;-----------------------------------

sub         ; Calc native pointers for A and B
            lda A
            sta HPTR
            lda A+1
            sta HPTR+1
            jsr SL_CalcNPTR
            lda NPTR
            sta A
            lda NPTR+1
            sta A+1
            lda B
            sta HPTR
            lda B+1
            sta HPTR+1
            jsr SL_CalcNPTR
            lda NPTR
            sta B
            lda NPTR+1
            sta B+1

            ; mem[B] = mem[B] - mem[A]
            ldy #00
            sec
            lda (B), y
            sbc (A), y
            sta (B), y
            iny
            lda (B), y
            sbc (A), y
            sta (B), y

            ; if (mem[B] <= 0) goto C
            lda (B), y               ; Y is 1 from above
            and #128                 ; Most significant bit
            bne jump
            lda (B), y
            bne fetch3
            dey                      ; Y will now be 0
            lda (B), y
            bne fetch3

            ; Goto C
jump        lda C
            sta PC
            lda C+1
            sta PC+1
fetch3      jmp fetch

halt        rts
.)


;---------------------------------
; Calculate the pointer to native
; memory from the host pointer.
; HPTR - host pointer
; NPTR - native pointer
;---------------------------------
SL_CalcNPTR ; First double HPTR because host memory is
            ; stored as 16-bit words
            clc
            lda HPTR
            adc HPTR
            sta NPTR
            lda HPTR+1
            adc HPTR+1
            sta NPTR+1
            ; Base pointer off SL_MEM
            clc
            lda NPTR
            adc #<SL_MEM
            sta NPTR
            lda NPTR+1
            adc #>SL_MEM
            sta NPTR+1
            rts
