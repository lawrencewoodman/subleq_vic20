;========================================================
; SUBLEQ Emulator
; Author  Lawrence woodman <lwoodman@vlifesystems.com>
; Date    31st March 2020
;--------------------------------------------------------
; Include as needed
;--------------------------------------------------------
; TODO check if A, B, and C are in range?
; TODO Add support for input via A == -1
;========================================================

; TODO prefix these with SL_
; TODO Check and document locations and probs
A           = $A7               ; A Operand
B           = $A9               ; B Operand
C           = $AB               ; C Operand
PC          = $BE               ; TODO Find better location
HPTR        = $92               ; TODO Find better location
NPTR        = $94               ; TODO Find better location
SKIPSUB     = $96               ; TODO Find better location
AVAL        = $3B               ; TODO Find better location
SL_MEM      = $1500             ; TODO Find better location

; SUBLEQ Ports
IN          = -1
OUT         = -1


;-------------------------------------------------
; Load a program into memory
;-------------------------------------------------
; Args:
;   SL_prog    Location of program to load. First
;              byte/word is the length of the program
;              in bytes.  Uses 16-bit words.
;   SL_MEM     Location of SUBLEQ memory
;-------------------------------------------------
; TODO Correct prog comment byte/word
; TODO put this into another program
; TODO Make possible to load > 128 16-bit word programs
;-------------------------------------------------
SL_loadProg  .(
            ; Get Program size and double it because
            ; program stored as 16-bit words
            clc
            lda SL_prog
            adc SL_prog

            ; Load program into SL_MEM
            tay
            ldx #$00
loop        lda SL_prog+1, x
            sta SL_MEM, x
            inx
            dey
            bne loop
            rts
.)


;-------------------------------------------------
; Run program
;-------------------------------------------------
; Args:
;   SL_MEM     Location of SUBLEQ memory
;-------------------------------------------------
SL_run      .(
GETIN       = $FFE4
CCHROUT     = $FFD2
            ; Zero PC
            lda #00
            sta PC
            sta PC+1

fetch       ; Check if PC valid (PC >= 0)
            lda PC+1
            and #128                 ; Most significant bit (sign bit)
            beq fetch1
            jmp halt

            ;--------------------
            ; Fetch operands A,B,C
            ;--------------------

fetch1      ; Calc native pointer for PC
            lda PC
            sta HPTR
            lda PC+1
            sta HPTR+1
            jsr SL_CalcNPTR

            ; Get A,B,C
            ldy #05
floop       lda (NPTR),y
            sta A,y
            dey
            bpl floop

            ; Move PC to start of next operands
            clc
            lda PC
            adc #03
            sta PC
            bcc fetchEnd
            inc PC+1
fetchEnd

            ; Check if A == -1 indicating that input should go to mem[B]
            lda #00
            sta SKIPSUB
            lda A
            cmp #<(IN)
            bne getAMemVal
            lda A+1
            cmp #>(IN)
            bne getAMemVal

            ; Get character from input
            ldy #01
            sta SKIPSUB           ; Record that should skip sub
getChar     jsr GETIN
            cmp #00
            beq getChar           ; Wait until a character is pressed
            sta AVAL
            lda #00
            sta AVAL+1
            jmp output


getAMemVal  ; Calc native pointer for A and get mem[A]
            lda A
            sta HPTR
            lda A+1
            sta HPTR+1
            jsr SL_CalcNPTR
            ldy #00
            lda (NPTR), y
            sta AVAL
            iny
            lda (NPTR), y
            sta AVAL+1

            ;--------------------------------------
            ; Output mem[A] or input to display
            ; if B == -1 and move to next operands
            ;--------------------------------------

output      ; Check if B == -1 indicating that mem[A] should be output
            lda B
            cmp #<(OUT)
            bne endOutput
            lda B+1
            cmp #>(OUT)
            bne endOutput

            ; Output LSB of mem[A] to display
            lda AVAL
            jsr CCHROUT
            jmp fetch
endOutput

            ; Calc native pointer B
            lda B
            sta HPTR
            lda B+1
            sta HPTR+1
            jsr SL_CalcNPTR

            ; Check if should skip sub
            lda SKIPSUB
            beq sub

            ; Store value indicated by A to mem[B]
            ldy #00
            lda AVAL
            sta (NPTR), y     ; NPTR is B as a native pointer
            iny
            lda AVAL+1
            sta (NPTR), y
            jmp fetch


            ;-----------------------------------
            ; Perform subtraction
            ; mem[B] = mem[B] - mem[A]
            ; TODO create routine to repoint A and B and use before SL_Output
            ;-----------------------------------

            ; mem[B] = mem[B] - mem[A]
sub         ldy #00
            sec
            lda (NPTR), y     ; NPTR is B as a native pointer
            sbc AVAL
            sta (NPTR), y
            iny
            lda (NPTR), y
            sbc AVAL
            sta (NPTR), y

            ; if (mem[B] <= 0) goto C
            ; NPTR is B as a native pointer
            lda (NPTR), y               ; Y is 1 from above
            and #128                 ; Most significant bit
            bne jump
            lda (NPTR), y
            bne fetch3
            dey                      ; Y will now be 0
            lda (NPTR), y
            bne fetch3

            ; Goto C
jump        lda C
            sta PC
            lda C+1
            sta PC+1
fetch3      jmp fetch

halt        rts
.)


;---------------------------------
; Calculate the pointer to native
; memory from the host pointer.
; HPTR - host pointer
; NPTR - native pointer
;---------------------------------
SL_CalcNPTR ; First double HPTR because host memory is
            ; stored as 16-bit words
            clc
            lda HPTR
            adc HPTR
            sta NPTR
            lda HPTR+1
            adc HPTR+1
            sta NPTR+1
            ; Base pointer off SL_MEM
            clc
            lda NPTR
            adc #<SL_MEM
            sta NPTR
            lda NPTR+1
            adc #>SL_MEM
            sta NPTR+1
            rts
